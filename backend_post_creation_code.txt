
--- START: flask_service/app/routes/community_routes.py ---
# app/routes/community_routes.py
from flask import Blueprint, request, jsonify, current_app
from flask_jwt_extended import jwt_required, get_jwt_identity
from app.models.community import Community
from app.models.post import Post 
from app.models.comment import Comment # Ensure this model is defined and imported
from bson import ObjectId, errors as bson_errors

# --- REVERTED TO YOUR ORIGINAL BLUEPRINT NAME ---
community_bp = Blueprint('community_bp', __name__)

# IMPORTANT: This blueprint (community_bp) should be registered in your main Flask app
# with a url_prefix like '/api/v1'.
# e.g., in app/__init__.py: app.register_blueprint(community_bp, url_prefix='/api/v1')
#
# Then, routes defined here will be relative to that.
# For example, @community_bp.route('/communities', ...) will become /api/v1/communities
# And @community_bp.route('/communities/<id>/posts', ...) will become /api/v1/communities/<id>/posts

# === Community Management Routes ===
@community_bp.route('/communities', methods=['POST'])
@jwt_required()
def create_community_route():
    data = request.get_json(); current_user_id = get_jwt_identity()
    try:
        new_community = Community.create_community(
            name=data.get('name'), 
            description=data.get('description'), 
            created_by_id_str=current_user_id,
            rules=data.get('rules'), 
            icon_url=data.get('icon'), # Expect camelCase from frontend
            banner_image_url=data.get('bannerImage'), # Expect camelCase
            tags=data.get('tags')
        )
        if not new_community:
             return jsonify({"status": "fail", "message": "Community could not be created."}), 400
        return jsonify({"status": "success", "data": {"community": new_community}}), 201
    except ValueError as ve: return jsonify({"status": "fail", "message": str(ve)}), 400
    except Exception as e: 
        current_app.logger.error(f"Error creating community: {e}", exc_info=True)
        return jsonify({"status": "error", "message": "Could not create community."}), 500

@community_bp.route('/communities', methods=['GET'])
@jwt_required(optional=True)
def get_communities_route():
    current_user_id_str = None
    try: user_identity = get_jwt_identity(); current_user_id_str = str(user_identity) if user_identity else None
    except Exception: pass
    try:
        page = request.args.get('page', 1, type=int); per_page = request.args.get('limit', 10, type=int)
        search_query = request.args.get('searchQuery', type=str)
        result = Community.get_all_communities(page=page, per_page=per_page, search_query=search_query, current_user_id_str=current_user_id_str)
        return jsonify({"status": "success", "data": result['communities'], "results": result['total'],
                        "pagination": {"totalItems": result['total'], "totalPages": result['pages'], 
                                       "currentPage": result['page'], "perPage": result['per_page']}}), 200
    except Exception as e: current_app.logger.error(f"Error list communities: {e}", exc_info=True); return jsonify({"status": "error", "message": "Failed list communities."}), 500

@community_bp.route('/communities/<string:community_id_or_slug>', methods=['GET'])
@jwt_required(optional=True)
def get_community_detail_route(community_id_or_slug):
    current_user_id_str = None
    try: user_identity = get_jwt_identity(); current_user_id_str = str(user_identity) if user_identity else None
    except Exception: pass
    try:
        community_dict = Community.find_by_id_or_slug(community_id_or_slug, current_user_id_str)
        if not community_dict: return jsonify({"status": "fail", "message": "Community not found."}), 404
        return jsonify({"status": "success", "data": {"community": community_dict}}), 200
    except Exception as e: current_app.logger.error(f"Err C detail {community_id_or_slug}: {e}", exc_info=True); return jsonify({"status": "error", "message": "Could not get C details."}), 500

@community_bp.route('/communities/<string:community_id>/join', methods=['POST'])
@jwt_required()
def join_community_route(community_id):
    current_user_id = get_jwt_identity()
    try:
        result = Community.join_community(community_id, current_user_id)
        status_code = 200
        if result.get("already_member"): status_code = 409
        elif not result.get("modified"): status_code = 400
        
        updated_community_data = Community.find_by_id_or_slug(community_id, current_user_id) if result.get("modified") else None
        
        return jsonify({
            "status": "success" if result.get("modified") else "fail", 
            "message": result["message"],
            "data": {"community": updated_community_data} if updated_community_data else None
        }), status_code
    except ValueError as ve: return jsonify({"status": "fail", "message": str(ve)}), 400
    except Exception as e: current_app.logger.error(f"Err joining C {community_id}: {e}", exc_info=True); return jsonify({"status": "error", "message": "Could not join community."}), 500

@community_bp.route('/communities/<string:community_id>/leave', methods=['POST'])
@jwt_required()
def leave_community_route(community_id):
    current_user_id = get_jwt_identity()
    try:
        result = Community.leave_community(community_id, current_user_id)
        status_code = 200
        if result.get("not_member"): status_code = 400
        elif not result.get("modified"): status_code = 400
        
        updated_community_data = Community.find_by_id_or_slug(community_id, current_user_id) if result.get("modified") else None

        return jsonify({
            "status": "success" if result.get("modified") else "fail", 
            "message": result["message"],
            "data": {"community": updated_community_data} if updated_community_data else None
        }), status_code
    except ValueError as ve: return jsonify({"status": "fail", "message": str(ve)}), 400
    except Exception as e: current_app.logger.error(f"Err leaving C {community_id}: {e}", exc_info=True); return jsonify({"status": "error", "message": "Could not leave community."}), 500


# === Post Management Routes ===
@community_bp.route('/communities/<string:community_id_from_url>/posts', methods=['POST'])
@jwt_required()
def create_post_in_community_route(community_id_from_url):
    current_user_id_str = get_jwt_identity(); data = request.get_json()
    try:
        new_post = Post.create_post(
            community_id_str=community_id_from_url, author_id_str=current_user_id_str, 
            title=data.get('title'), content_type=data.get('contentType'),
            content_text=data.get('contentText'), image_url=data.get('imageUrl'), 
            link_url=data.get('linkUrl'), tags=data.get('tags')
        )
        return jsonify({"status": "success", "data": {"post": new_post}}), 201
    except ValueError as ve: return jsonify({"status": "fail", "message": str(ve)}), 400
    except Exception as e: current_app.logger.error(f"Err creating post in C:{community_id_from_url}: {e}", exc_info=True); return jsonify({"status": "error", "message": "Could not create post."}), 500

# THIS IS THE ROUTE THAT WAS GIVING 404
@community_bp.route('/communities/<string:community_id>/posts', methods=['GET'])
@jwt_required(optional=True)
def get_posts_for_community_route(community_id):
    current_app.logger.info(f"--- FLASK ROUTE HIT: /communities/{community_id}/posts (Full path from Blueprint root) ---")
    current_user_id_str = None
    try: user_identity = get_jwt_identity(); current_user_id_str = str(user_identity) if user_identity else None
    except Exception: pass
    
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('limit', 10, type=int)
        sort_by = request.args.get('sortBy', 'new', type=str).lower()
        
        if page < 1: page = 1
        
        # Corrected per_page validation
        if per_page < 1:
            per_page = 1
        elif per_page > 50:
            per_page = 50
            
        if sort_by not in ['new', 'hot', 'top']: sort_by = 'new'
            
        result = Post.get_posts_for_community_for_user(
            community_id_str=community_id, current_user_id_str=current_user_id_str, 
            page=page, per_page=per_page, sort_by=sort_by
        )
        
        current_app.logger.info(f"--- FLASK: Posts for C:{community_id} - Found: {len(result.get('posts',[]))}, Total: {result.get('total',0)} ---")
        return jsonify({"status": "success", "data": result.get('posts',[]), "results": result.get('total',0),
                        "pagination": {"totalItems": result.get('total',0), "totalPages": result.get('pages',0), 
                                       "currentPage": result.get('page',1), "perPage": result.get('per_page',10), "sortBy": sort_by }}), 200
    except ValueError as ve: current_app.logger.warn(f"ValueError C posts {community_id}: {ve}"); return jsonify({"status": "fail", "message": str(ve)}), 404
    except Exception as e: current_app.logger.error(f"Error C posts {community_id}: {e}", exc_info=True); return jsonify({"status": "error", "message": "Failed to get posts."}), 500

# Routes for individual posts: GET /posts/:id, PUT /posts/:id, DELETE /posts/:id, POST /posts/:id/vote
# These are defined directly on community_bp. If community_bp is registered with url_prefix='/api/v1',
# these routes will become /api/v1/posts/<post_id> etc.
# This assumes your Node.js proxy forwards requests for /api/v1/posts/* to Flask.
@community_bp.route('/posts/<string:post_id>', methods=['GET'])
@jwt_required(optional=True)
def get_post_detail_route(post_id):
    current_user_id_str = None
    try: user_identity = get_jwt_identity(); current_user_id_str = str(user_identity) if user_identity else None
    except Exception: pass
    try:
        post = Post.find_by_id_for_user(post_id, current_user_id_str) 
        if not post: return jsonify({"status": "fail", "message": "Post not found."}), 404
        return jsonify({"status": "success", "data": {"post": post}}), 200
    except Exception as e: current_app.logger.error(f"Err get post {post_id}: {e}", exc_info=True); return jsonify({"status": "error", "message": "Could not get post."}), 500

@community_bp.route('/posts/<string:post_id>', methods=['PUT'])
@jwt_required()
def update_post_route(post_id):
    current_user_id_str = get_jwt_identity(); data = request.get_json()
    if not data: return jsonify({"status": "fail", "message": "Request body is empty."}), 400
    update_payload = {key: data[key] for key in ["title", "contentText", "imageUrl", "linkUrl", "tags"] if key in data}
    if not update_payload: return jsonify({"status": "fail", "message": "No updatable fields."}), 400
    try:
        result = Post.update_post(post_id, current_user_id_str, update_payload)
        return jsonify({"status": "success", "message": result.get("message", "Post updated."), "data": {"post": result.get("post")}}), 200
    except ValueError as ve: return jsonify({"status": "fail", "message": str(ve)}), 404 if "not found" in str(ve).lower() else 400
    except PermissionError as pe: return jsonify({"status": "fail", "message": str(pe)}), 403
    except Exception as e: current_app.logger.error(f"Err updating post {post_id}: {e}", exc_info=True); return jsonify({"status": "error", "message": "Could not update post."}), 500

@community_bp.route('/posts/<string:post_id>', methods=['DELETE'])
@jwt_required()
def delete_post_route(post_id):
    current_user_id_str = get_jwt_identity()
    try:
        success = Post.delete_post(post_id_str=post_id, user_id_str=current_user_id_str)
        if success: return jsonify({"status": "success", "message": "Post deleted."}), 200
        else: return jsonify({"status": "fail", "message": "Post not found or not authorized."}), 404
    except ValueError as ve: return jsonify({"status": "fail", "message": str(ve)}), 404
    except PermissionError as pe: return jsonify({"status": "fail", "message": str(pe)}), 403
    except Exception as e: current_app.logger.error(f"Err deleting post {post_id}: {e}", exc_info=True); return jsonify({"status": "error", "message": "Could not delete post."}), 500

@community_bp.route('/posts/<string:post_id>/vote', methods=['POST'])
@jwt_required()
def vote_on_post_route(post_id):
    current_user_id_str = get_jwt_identity(); data = request.get_json(); direction = data.get('direction')
    if not direction or direction not in ["up", "down", "none"]: return jsonify({"status": "fail", "message": "Invalid vote direction."}), 400
    try:
        # Assuming Post.vote_on_post returns a dict that can be directly used for VoteApiResponse.data
        updated_post_data = Post.vote_on_post(post_id, current_user_id_str, direction)
        return jsonify({"status": "success", "message": "Vote processed.", 
                        "data": { # Ensure this matches VoteApiResponse
                            "upvotes": updated_post_data.get("upvotes"), 
                            "downvotes": updated_post_data.get("downvotes"), 
                            "user_vote": updated_post_data.get("userVote") # Expecting userVote from model
                        }}), 200
    except ValueError as ve: return jsonify({"status": "fail", "message": str(ve)}), 404 if "not found" in str(ve).lower() else 400
    except Exception as e: current_app.logger.error(f"Err voting on post {post_id}: {e}", exc_info=True); return jsonify({"status": "error", "message": "Could not process vote."}), 500

# === Comment Management Routes ===
@community_bp.route('/posts/<string:post_id>/comments', methods=['POST'])
@jwt_required()
def create_comment_on_post_route(post_id):
    current_user_id_str = get_jwt_identity(); data = request.get_json(); text = data.get('text')
    parent_comment_id_str = data.get('parentCommentId')
    if not text or not text.strip(): return jsonify({"status": "fail", "message": "Comment text required."}), 400
    try:
        new_comment = Comment.create_comment(post_id_str=post_id, author_id_str=current_user_id_str, text=text, parent_comment_id_str=parent_comment_id_str)
        return jsonify({"status": "success", "data": {"comment": new_comment}}), 201
    except ValueError as ve: return jsonify({"status": "fail", "message": str(ve)}), 404 if "not found" in str(ve).lower() else 400
    except Exception as e: current_app.logger.error(f"Err creating comment on P:{post_id}: {e}", exc_info=True); return jsonify({"status": "error", "message": "Could not create comment."}), 500

@community_bp.route('/posts/<string:post_id>/comments', methods=['GET'])
@jwt_required(optional=True) 
def get_comments_for_post_route(post_id):
    current_user_id_str = None
    try: user_identity = get_jwt_identity(); current_user_id_str = str(user_identity) if user_identity else None
    except Exception: pass
    try:
        page = request.args.get('page', 1, type=int); per_page = request.args.get('limit', 20, type=int)
        sort_by = request.args.get('sortBy', 'newest', type=str).lower()
        
        if page < 1: page = 1
        # Corrected syntax here
        if per_page < 1:
            per_page = 1
        elif per_page > 100: 
            per_page = 100
            
        if sort_by not in ['newest', 'oldest', 'top']: sort_by = 'newest'
        
        result = Comment.get_comments_for_post_for_user(
            post_id_str=post_id, current_user_id_str=current_user_id_str, 
            page=page, per_page=per_page, sort_by=sort_by, parent_id_str=None 
        )
        return jsonify({"status": "success", "data": result.get('comments',[]), "results": result.get('total',0),
                        "pagination": {"totalItems": result.get('total',0), "totalPages": result.get('pages',0), 
                                       "currentPage": result.get('page',1), "perPage": result.get('per_page',10), "sortBy": sort_by}}), 200
    except ValueError as ve: return jsonify({"status": "fail", "message": str(ve)}), 400
    except Exception as e: current_app.logger.error(f"Err fetching comments for P:{post_id}: {e}", exc_info=True); return jsonify({"status": "error", "message": "Failed to get comments."}), 500

# app/routes/community_routes.py
# ... (other imports and blueprint definition) ...

# GET /api/v1/comments/<commentId>/replies - List REPLIES for a specific comment
# (This path assumes community_bp is registered at /api/v1 and this route is /comments/... on it)
# OR /api/v1/communities/comments/... if that's the full path based on blueprint prefixing.
# Based on previous files, this seems to be on community_bp.
@community_bp.route('/comments/<string:parent_comment_id>/replies', methods=['GET'])
@jwt_required(optional=True)
def get_replies_for_comment_route(parent_comment_id):
    current_user_id_str = None
    try: 
        user_identity = get_jwt_identity()
        current_user_id_str = str(user_identity) if user_identity else None
    except Exception: 
        pass
    
    try:
        parent_comment = Comment.find_by_id(parent_comment_id)
        if not parent_comment: 
            return jsonify({"status": "fail", "message": "Parent comment not found."}), 404
        
        post_id_for_replies = parent_comment.get("postId") # Expect camelCase 'postId' from Comment model
        if not post_id_for_replies: 
            return jsonify({"status": "error", "message": "Parent comment missing post association."}), 500

        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('limit', 10, type=int) # Fewer replies per page
        sort_by = request.args.get('sortBy', 'oldest', type=str).lower() # Replies often shown oldest first
        
        if page < 1: 
            page = 1
        
        # CORRECTED SYNTAX FOR per_page:
        if per_page < 1:
            per_page = 1
        elif per_page > 50: # Max limit
            per_page = 50
            
        if sort_by not in ['newest', 'oldest']: # Assuming 'top' might not apply well to replies here
            sort_by = 'oldest'

        result = Comment.get_comments_for_post_for_user( # This method fetches comments/replies
            post_id_str=str(post_id_for_replies), 
            current_user_id_str=current_user_id_str, 
            page=page, per_page=per_page, sort_by=sort_by, 
            parent_id_str=parent_comment_id # Pass the parent_id to fetch its children (replies)
        )
        return jsonify({
            "status": "success", "data": result.get('comments',[]), "results": result.get('total',0),
            "pagination": {
                "totalItems": result.get('total',0), "totalPages": result.get('pages',0),
                "currentPage": result.get('page',1), "perPage": result.get('per_page',10),
                "sortBy": sort_by
            }
        }), 200
    except ValueError as ve: 
        current_app.logger.warn(f"ValueError getting replies for Cmnt:{parent_comment_id}: {ve}")
        return jsonify({"status": "fail", "message": str(ve)}), 400
    except Exception as e: 
        current_app.logger.error(f"Err fetching replies for Cmnt:{parent_comment_id}: {e}", exc_info=True)
        return jsonify({"status": "error", "message": "Failed to get replies."}), 500

# ... (rest of your community_routes.py)
@community_bp.route('/comments/<string:comment_id>/vote', methods=['POST'])
@jwt_required()
def vote_on_comment_route(comment_id):
    current_user_id_str = get_jwt_identity(); data = request.get_json(); direction = data.get('direction')
    if not direction or direction not in ["up", "down", "none"]: return jsonify({"status": "fail", "message": "Invalid vote direction."}), 400
    try:
        result_dict = Comment.vote_on_comment(comment_id, current_user_id_str, direction) # Assuming this method exists
        return jsonify({"status": "success", "message": result_dict.get("message"), 
                        "data": {"upvotes": result_dict.get("upvotes"), "downvotes": result_dict.get("downvotes"), 
                                 "user_vote": result_dict.get("userVote")}}), 200
    except ValueError as ve: return jsonify({"status": "fail", "message": str(ve)}), 404 if "not found" in str(ve).lower() else 400
    except Exception as e: current_app.logger.error(f"Err voting on Cmnt {comment_id}: {e}", exc_info=True); return jsonify({"status": "error", "message": "Could not process vote."}), 500

@community_bp.route('/comments/<string:comment_id>', methods=['PUT'])
@jwt_required()
def update_comment_route(comment_id):
    current_user_id_str = get_jwt_identity(); data = request.get_json(); new_text = data.get('text')
    if not new_text or not new_text.strip(): return jsonify({"status": "fail", "message": "Comment text required."}), 400
    try:
        updated_comment = Comment.update_comment(comment_id_str=comment_id, author_id_str=current_user_id_str, new_text=new_text) # Assuming this method exists
        return jsonify({"status": "success", "data": {"comment": updated_comment}}), 200
    except ValueError as ve: return jsonify({"status": "fail", "message": str(ve)}), 404 if "not found" in str(ve).lower() else 400
    except PermissionError as pe: return jsonify({"status": "fail", "message": str(pe)}), 403
    except Exception as e: current_app.logger.error(f"Err updating Cmnt {comment_id}: {e}", exc_info=True); return jsonify({"status": "error", "message": "Could not update comment."}), 500

@community_bp.route('/comments/<string:comment_id>', methods=['DELETE'])
@jwt_required()
def delete_comment_route(comment_id):
    current_user_id_str = get_jwt_identity()
    try:
        success = Comment.delete_comment(comment_id_str=comment_id, user_id_str=current_user_id_str) # Assuming this method exists
        if success: return jsonify({"status": "success", "message": "Comment deleted."}), 200
        else: return jsonify({"status": "fail", "message": "Comment not found or not authorized."}), 404
    except ValueError as ve: return jsonify({"status": "fail", "message": str(ve)}), 404
    except PermissionError as pe: return jsonify({"status": "fail", "message": str(pe)}), 403
    except Exception as e: current_app.logger.error(f"Err deleting Cmnt {comment_id}: {e}", exc_info=True); return jsonify({"status": "error", "message": "Could not delete comment."}), 500
--- END: flask_service/app/routes/community_routes.py ---


--- START: flask_service/app/models/post.py ---
# app/models/post.py
from app import mongo
from datetime import datetime
from bson import ObjectId
from app.models.community import Community 
from flask import current_app
# Import Comment model here as Post.delete_post will interact with it
from app.models.comment import Comment 

class Post:
    @staticmethod
    def get_collection():
        return mongo.db.posts

    @staticmethod
    def create_post(community_id_str, author_id_str, title, content_type, content_text=None, image_url=None, link_url=None, tags=None):
        if not community_id_str: raise ValueError("Community ID is required.")
        if not author_id_str: raise ValueError("Author ID is required.")
        if not title or len(title.strip()) < 3: raise ValueError("Post title required (min 3 chars).")
        if content_type not in ["text", "image", "link"]: raise ValueError("Invalid post content type.")

        if content_type == "text" and not (content_text and content_text.strip()): raise ValueError("Text content required for text post.")
        if content_type == "image" and not image_url: raise ValueError("Image URL required for image post.")
        if content_type == "link" and not link_url: raise ValueError("Link URL required for link post.")
        
        community = Community.find_by_id(community_id_str) 
        if not community:
            if not ObjectId.is_valid(community_id_str): 
                community = Community.find_by_slug(community_id_str)
            if not community: 
                raise ValueError(f"Community '{community_id_str}' not found.")
            community_id_str = community['id'] # Use the actual ID if found by slug

        try:
            community_id_obj = ObjectId(community_id_str)
            author_id_obj = ObjectId(author_id_str)
        except Exception: 
            raise ValueError("Invalid Community ID or Author ID format.")

        post_data = {
            "community_id": community_id_obj, 
            "community_slug": community.get('slug'), 
            "community_name": community.get('name'), 
            "author_id": author_id_obj,
            "title": title.strip(), 
            "content_type": content_type,
            "content_text": content_text.strip() if content_text else None,
            "image_url": image_url, 
            "link_url": link_url,
            "tags": [tag.strip().lower() for tag in tags if isinstance(tag, str) and tag.strip()] if tags else [],
            "upvotes": 0, 
            "downvotes": 0, 
            "upvoted_by": [], 
            "downvoted_by": [],
            "comment_count": 0, 
            "created_at": datetime.utcnow(),
            "updated_at": datetime.utcnow(), 
            "last_activity_at": datetime.utcnow() 
        }
        result = Post.get_collection().insert_one(post_data)
        post_data['_id'] = result.inserted_id
        return Post.to_dict(post_data, current_user_id_str=str(author_id_obj))

    @staticmethod
    def vote_on_post(post_id_str, user_id_str, vote_direction):
        try:
            post_id_obj = ObjectId(post_id_str); user_id_obj = ObjectId(user_id_str)
        except Exception: raise ValueError("Invalid Post/User ID format for vote.")
        post = Post.get_collection().find_one({"_id": post_id_obj})
        if not post: raise ValueError("Post not found for vote.")

        is_up = user_id_obj in post.get("upvoted_by", [])
        is_down = user_id_obj in post.get("downvoted_by", [])
        pull_ops, add_ops, inc_ops = {}, {}, {}

        if vote_direction == "up":
            if is_up: pull_ops["upvoted_by"] = user_id_obj; inc_ops["upvotes"] = -1
            else:
                if is_down: pull_ops["downvoted_by"] = user_id_obj; inc_ops["downvotes"] = -1
                add_ops["upvoted_by"] = user_id_obj; inc_ops["upvotes"] = 1
        elif vote_direction == "down":
            if is_down: pull_ops["downvoted_by"] = user_id_obj; inc_ops["downvotes"] = -1
            else:
                if is_up: pull_ops["upvoted_by"] = user_id_obj; inc_ops["upvotes"] = -1
                add_ops["downvoted_by"] = user_id_obj; inc_ops["downvotes"] = 1
        elif vote_direction == "none":
            if is_up: pull_ops["upvoted_by"] = user_id_obj; inc_ops["upvotes"] = -1
            if is_down: pull_ops["downvoted_by"] = user_id_obj; inc_ops["downvotes"] = -1
        else: raise ValueError("Invalid vote direction.")

        update_q = {}; msg = "No change in vote status."
        if pull_ops: update_q["$pull"] = pull_ops
        if add_ops: update_q["$addToSet"] = add_ops
        if inc_ops: update_q["$inc"] = inc_ops
        if update_q:
            update_q["$set"] = {"updated_at": datetime.utcnow(), "last_activity_at": datetime.utcnow()}
            res = Post.get_collection().update_one({"_id": post_id_obj}, update_q)
            if res.modified_count > 0 or (inc_ops and res.matched_count > 0): msg = "Vote processed."
        
        curr_doc = Post.get_collection().find_one({"_id": post_id_obj})
        curr_dict = Post.to_dict(curr_doc, user_id_str)
        return {"message": msg, "upvotes": curr_dict.get("upvotes"), "downvotes": curr_dict.get("downvotes"), "user_vote": curr_dict.get("user_vote")}

    @staticmethod
    def update_post(post_id_str, author_id_str, update_data):
        try:
            post_id_obj = ObjectId(post_id_str); author_id_obj = ObjectId(author_id_str)
        except Exception: raise ValueError("Invalid Post/Author ID for update.")
        post = Post.get_collection().find_one({"_id": post_id_obj})
        if not post: raise ValueError("Post not found for update.")
        if post.get("author_id") != author_id_obj: raise PermissionError("Not authorized to edit post.")

        allowed_updates = {}
        if "title" in update_data:
            title = update_data["title"].strip() if update_data["title"] else ""
            if len(title) < 3: raise ValueError("Updated title too short (min 3 chars).")
            allowed_updates["title"] = title
        
        content_type = post.get("content_type")
        if "content_text" in update_data:
            allowed_updates["content_text"] = update_data["content_text"].strip() if update_data["content_text"] else None
            if content_type == "text" and not allowed_updates["content_text"]: raise ValueError("Text content cannot be empty.")
        if "image_url" in update_data and content_type == "image":
            if not update_data["image_url"]: raise ValueError("Image URL cannot be empty.")
            allowed_updates["image_url"] = update_data["image_url"]
        if "link_url" in update_data and content_type == "link":
            if not update_data["link_url"]: raise ValueError("Link URL cannot be empty.")
            allowed_updates["link_url"] = update_data["link_url"]
        if "tags" in update_data and isinstance(update_data["tags"], list):
            allowed_updates["tags"] = [tag.strip().lower() for tag in update_data["tags"] if isinstance(tag, str) and tag.strip()]
        
        if not allowed_updates: return {"message": "No valid fields or changes.", "post": Post.to_dict(post, author_id_str)}
        allowed_updates["updated_at"] = datetime.utcnow()

        res = Post.get_collection().update_one({"_id": post_id_obj, "author_id": author_id_obj}, {"$set": allowed_updates})
        updated_doc = Post.get_collection().find_one({"_id": post_id_obj})
        msg = "No changes detected."
        if res.modified_count > 0: msg = "Post updated successfully."
        return {"message": msg, "post": Post.to_dict(updated_doc, author_id_str)}

    @staticmethod
    def delete_post(post_id_str, user_id_str):
        try:
            post_id_obj = ObjectId(post_id_str)
            user_id_obj = ObjectId(user_id_str)
        except Exception: raise ValueError("Invalid Post ID or User ID format for delete.")
        post = Post.get_collection().find_one({"_id": post_id_obj})
        if not post: raise ValueError("Post not found to delete.")
        if post.get("author_id") != user_id_obj: raise PermissionError("User is not authorized to delete this post.")

        try:
            comment_delete_result = Comment.get_collection().delete_many({"post_id": post_id_obj})
            current_app.logger.info(f"Cascaded delete: {comment_delete_result.deleted_count} comments for post {post_id_str}")
        except Exception as e:
            current_app.logger.error(f"Error during cascading delete of comments for post {post_id_str}: {e}", exc_info=True)

        delete_result = Post.get_collection().delete_one({"_id": post_id_obj, "author_id": user_id_obj})
        if delete_result.deleted_count > 0: return True
        else:
            current_app.logger.warning(f"Post {post_id_str} delete op by author {user_id_str} affected 0 docs, though post was found.")
            return False

    @staticmethod
    def to_dict(post_doc, current_user_id_str=None):
        if not post_doc: return None
        data = {
            "id": str(post_doc["_id"]),
            "community_id": str(post_doc.get("community_id")),
            "community_slug": post_doc.get("community_slug"),
            "community_name": post_doc.get("community_name"),
            "author_id": str(post_doc.get("author_id")),
            "title": post_doc.get("title"), "content_type": post_doc.get("content_type"),
            "content_text": post_doc.get("content_text"), "image_url": post_doc.get("image_url"),
            "link_url": post_doc.get("link_url"), "tags": post_doc.get("tags", []),
            "upvotes": post_doc.get("upvotes", 0), "downvotes": post_doc.get("downvotes", 0),
            "comment_count": post_doc.get("comment_count", 0),
            "created_at": post_doc.get("created_at").isoformat() if post_doc.get("created_at") else None,
            "updated_at": post_doc.get("updated_at").isoformat() if post_doc.get("updated_at") else None,
            "last_activity_at": post_doc.get("last_activity_at").isoformat() if post_doc.get("last_activity_at") else None,
            "user_vote": None 
        }
        if current_user_id_str:
            try:
                user_obj_id = ObjectId(current_user_id_str)
                if user_obj_id in post_doc.get("upvoted_by", []): data["user_vote"] = "up"
                elif user_obj_id in post_doc.get("downvoted_by", []): data["user_vote"] = "down"
            except Exception as e: current_app.logger.warning(f"Vote determination error for user {current_user_id_str} on post {data['id']}: {e}")
        return data

    @staticmethod
    def find_by_id_for_user(post_id_str, current_user_id_str=None):
        try:
            post_doc = Post.get_collection().find_one({"_id": ObjectId(post_id_str)})
            return Post.to_dict(post_doc, current_user_id_str) if post_doc else None
        except Exception: return None

    @staticmethod
    def get_posts_for_community_for_user(community_id_str, current_user_id_str=None, page=1, per_page=10, sort_by="new"):
        try:
            community_id_obj = ObjectId(community_id_str)
        except Exception: raise ValueError("Invalid Community ID format")
        query = {"community_id": community_id_obj}
        sort_field, sort_order = "created_at", -1 
        if sort_by == "hot": sort_field = "last_activity_at" 
        elif sort_by == "top": sort_field = "upvotes"
        skip_count = (page - 1) * per_page
        posts_cursor = Post.get_collection().find(query).sort(sort_field, sort_order).skip(skip_count).limit(per_page)
        posts_list = [Post.to_dict(post, current_user_id_str) for post in posts_cursor]
        total_posts = Post.get_collection().count_documents(query)
        return {
            "posts": posts_list, "total": total_posts, "page": page,
            "per_page": per_page, "pages": (total_posts + per_page - 1) // per_page if per_page > 0 else 0
        }
    # app/models/post.py
# ... (previous Post model code) ...

    @staticmethod
    def delete_post(post_id_str, user_id_str): 
        try:
            post_id_obj = ObjectId(post_id_str)
            user_id_obj = ObjectId(user_id_str)
        except bson_errors.InvalidId: # Use bson_errors
            raise ValueError("Invalid Post ID or User ID format for delete.")

        post = Post.get_collection().find_one({"_id": post_id_obj})
        if not post:
            raise ValueError("Post not found to delete.")

        if post.get("author_id") != user_id_obj:
            raise PermissionError("User is not authorized to delete this post.")

        # 1. Delete all comments associated with this post
        try:
            # Use the Comment model or direct collection access
            comment_delete_result = mongo.db.comments.delete_many({"post_id": post_id_obj}) # Direct access
            # OR if Comment model has a static method for this:
            # comment_delete_result = Comment.delete_all_for_post(post_id_obj) 
            current_app.logger.info(f"Cascaded delete: {comment_delete_result.deleted_count} comments for post {post_id_str}")
        except Exception as e:
            current_app.logger.error(f"Error during cascading delete of comments for post {post_id_str}: {e}", exc_info=True)

        # 2. Delete the post itself
        delete_result = Post.get_collection().delete_one({"_id": post_id_obj, "author_id": user_id_obj})

        if delete_result.deleted_count > 0:
            return True
        else:
            current_app.logger.warning(f"Post {post_id_str} delete operation by author {user_id_str} affected 0 documents, though post was initially found.")
            return False
# ... (rest of Post model)
--- END: flask_service/app/models/post.py ---


--- START: flask_service/app/__init__.py (relevant parts for request parsing if any) ---
from flask import Flask, jsonify
        return jsonify({"status": "healthy"}), 200
        return jsonify({"status": "error", "message": "Missing Authorization Header"}), 401
        return jsonify({"status": "error", "message": "Invalid or expired token"}), 401
        return jsonify({"status": "error", "message": "Token has expired"}), 401
        return jsonify({"status": "error", "message": "Fresh token required"}), 401

(Note: For __init__.py, only lines matching certain keywords were included to keep it concise. Review the full file if needed.)
--- END: flask_service/app/__init__.py ---


--- START: node_service/src/routes/proxyCommunityRoutes.js ---
// node_service/src/routes/proxyCommunityRoutes.js
const express = require('express');
const axios = require('axios');
const forwardAuthHeader = require('../middleware/forwardAuthHeader');
const router = express.Router();

const FLASK_COMMUNITY_URL_BASE = `${process.env.FLASK_API_BASE_URL}`;

const handleProxy = async (req, res, next, method, flaskEndpoint, data = null) => {
    try {
        // Construct the full Flask URL including any path parameters
        // req.originalUrl includes the full path after /api/v1, e.g. /communities/some-id/posts
        // req.path might be just /posts if the router is mounted on /communities/:id
        // For simplicity, we'll reconstruct.
        
        let fullFlaskUrl = `${FLASK_COMMUNITY_URL_BASE}${req.originalUrl.substring(req.baseUrl.length)}`;
        // req.baseUrl for this router will be empty if mounted at /api/v1 directly.
        // Or, if router is mounted as router.use('/communities', proxyCommunityRoutes), req.baseUrl would be /communities
        // Let's assume for this file, it handles /communities, /posts, /comments.
        // So, the full path is just req.originalUrl AFTER the /api/v1 prefix from the main router.
        // FLASK_COMMUNITY_URL_BASE already is http://flask_app:8000/api/v1
        // So we just need the part of req.originalUrl that comes AFTER /api/v1
        // For example, if Node route is /api/v1/communities and originalUrl is /api/v1/communities?page=1
        // then the path to append is /communities?page=1
        // A simpler way if FLASK_COMMUNITY_URL_BASE doesn't include /api/v1, but points to flask_app:8000
        // FLASK_RAW_BASE = http://flask_app:8000
        // fullFlaskUrl = `${FLASK_RAW_BASE}${req.originalUrl}` (if req.originalUrl is /api/v1/communities/...)
        // Let's assume FLASK_API_BASE_URL = http://flask_app:8000/api/v1
        // And this router is mounted at /api/v1 in Node.
        // Then if a request comes to Node at /api/v1/communities, req.path is /communities
        fullFlaskUrl = `${FLASK_COMMUNITY_URL_BASE}${req.path}`;
        if (Object.keys(req.params).length > 0) { // If there are path parameters like :communityId
            // This logic is tricky. A general proxy is hard.
            // It's often easier to define each route explicitly if paths differ or params are complex.
            // For now, let's rely on explicit path construction for each proxied route.
        }


        console.log(`Node: Proxying ${method} ${req.originalUrl} to Flask: ${flaskEndpoint}`);
        const axiosConfig = { method, url: flaskEndpoint, headers: req.flaskHeaders, params: req.query };
        if (data && (method.toLowerCase() === 'post' || method.toLowerCase() === 'put')) {
             axiosConfig.data = data;
        }
        
        const flaskResponse = await axios(axiosConfig);
        console.log(`Node: Flask response for ${req.originalUrl} - Status: ${flaskResponse.status}`);
        res.status(flaskResponse.status).json(flaskResponse.data);
    } catch (error) {
        console.error(`Node: Error proxying ${req.originalUrl} to Flask:`, error.message);
        if (error.response) { 
            console.error("Flask Error Data:", JSON.stringify(error.response.data));
            res.status(error.response.status).json(error.response.data); 
        } else { 
            res.status(502).json({ status: 'error', message: 'Bad gateway to community service.' }); 
        }
    }
};

// --- Communities ---
router.post('/communities', forwardAuthHeader, (req, res, next) => {
    handleProxy(req, res, next, 'post', `${FLASK_COMMUNITY_URL_BASE}/communities`, req.body);
});
router.get('/communities', forwardAuthHeader, (req, res, next) => {
    handleProxy(req, res, next, 'get', `${FLASK_COMMUNITY_URL_BASE}/communities`);
});
router.get('/communities/:communityIdOrSlug', forwardAuthHeader, (req, res, next) => {
    handleProxy(req, res, next, 'get', `${FLASK_COMMUNITY_URL_BASE}/communities/${req.params.communityIdOrSlug}`);
});
router.post('/communities/:communityId/join', forwardAuthHeader, (req, res, next) => {
    handleProxy(req, res, next, 'post', `${FLASK_COMMUNITY_URL_BASE}/communities/${req.params.communityId}/join`);
});
router.post('/communities/:communityId/leave', forwardAuthHeader, (req, res, next) => {
    handleProxy(req, res, next, 'post', `${FLASK_COMMUNITY_URL_BASE}/communities/${req.params.communityId}/leave`);
});

// --- Posts ---
router.post('/communities/:communityId/posts', forwardAuthHeader, (req, res, next) => {
    handleProxy(req, res, next, 'post', `${FLASK_COMMUNITY_URL_BASE}/communities/${req.params.communityId}/posts`, req.body);
});
router.get('/communities/:communityId/posts', forwardAuthHeader, (req, res, next) => {
    handleProxy(req, res, next, 'get', `${FLASK_COMMUNITY_URL_BASE}/communities/${req.params.communityId}/posts`);
});
// Note: GET /posts/:postId, PUT /posts/:postId, DELETE /posts/:postId also need specific handling if mounted here.
// It's cleaner if routes for /posts and /comments are separate from /communities in Node router structure too.
// For now, adding them here:
router.get('/posts/:postId', forwardAuthHeader, (req, res, next) => {
    handleProxy(req, res, next, 'get', `${FLASK_COMMUNITY_URL_BASE}/posts/${req.params.postId}`);
});
router.put('/posts/:postId', forwardAuthHeader, (req, res, next) => {
    handleProxy(req, res, next, 'put', `${FLASK_COMMUNITY_URL_BASE}/posts/${req.params.postId}`, req.body);
});
router.delete('/posts/:postId', forwardAuthHeader, (req, res, next) => {
    handleProxy(req, res, next, 'delete', `${FLASK_COMMUNITY_URL_BASE}/posts/${req.params.postId}`);
});
router.post('/posts/:postId/vote', forwardAuthHeader, (req, res, next) => {
    handleProxy(req, res, next, 'post', `${FLASK_COMMUNITY_URL_BASE}/posts/${req.params.postId}/vote`, req.body);
});

// --- Comments ---
router.post('/posts/:postId/comments', forwardAuthHeader, (req, res, next) => {
    handleProxy(req, res, next, 'post', `${FLASK_COMMUNITY_URL_BASE}/posts/${req.params.postId}/comments`, req.body);
});
router.get('/posts/:postId/comments', forwardAuthHeader, (req, res, next) => {
    handleProxy(req, res, next, 'get', `${FLASK_COMMUNITY_URL_BASE}/posts/${req.params.postId}/comments`);
});
router.get('/comments/:commentId/replies', forwardAuthHeader, (req, res, next) => {
    handleProxy(req, res, next, 'get', `${FLASK_COMMUNITY_URL_BASE}/comments/${req.params.commentId}/replies`);
});
router.put('/comments/:commentId', forwardAuthHeader, (req, res, next) => {
    handleProxy(req, res, next, 'put', `${FLASK_COMMUNITY_URL_BASE}/comments/${req.params.commentId}`, req.body);
});
router.delete('/comments/:commentId', forwardAuthHeader, (req, res, next) => {
    handleProxy(req, res, next, 'delete', `${FLASK_COMMUNITY_URL_BASE}/comments/${req.params.commentId}`);
});
router.post('/comments/:commentId/vote', forwardAuthHeader, (req, res, next) => {
    handleProxy(req, res, next, 'post', `${FLASK_COMMUNITY_URL_BASE}/comments/${req.params.commentId}/vote`, req.body);
});

module.exports = router;
--- END: node_service/src/routes/proxyCommunityRoutes.js ---


--- START: node_service/src/app.js ---
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors'); // <-- import cors
const mainRouter = require('./routes');

const app = express();

// ✅ Enable CORS for multiple frontend origins
const allowedOrigins = [
  'https://unicampusrit.netlify.app',
  'http://localhost:3000',
  'https://your-other-frontend.com',
  'https://refactored-space-winner-9wgrw9gjxrphx5r9-8080.app.github.dev',
  'https://fuzzy-space-doodle-v4774w5qq7wf5jg-8080.app.github.dev'// newly added origin
];

const corsOptions = {
  origin: function (origin, callback) {
    if (!origin) return callback(null, true); // allow tools like Postman
    if (allowedOrigins.includes(origin)) {
      return callback(null, true);
    } else {
      return callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true
};

app.use(cors(corsOptions));

// MongoDB connection
const dbURI = process.env.RESOURCES_MONGO_URI;
if (!dbURI) {
    console.error("FATAL ERROR: RESOURCES_MONGO_URI is not defined. Set it in node_service/.env");
    process.exit(1);
}

mongoose.connect(dbURI)
    .then(() => console.log('Node service successfully connected to MongoDB for Resources.'))
    .catch(err => {
        console.error('Node service MongoDB connection error for Resources:', err.message);
    });

app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Health check endpoint
app.get('/health', (req, res) => {
  res.status(200).json({ status: 'healthy', service: 'Node.js Gateway/Resource Service' });
});

// API routing
app.use('/api/v1', mainRouter);

// Global error handler
app.use((err, req, res, next) => {
  console.error("Node Service Error:", err.message);
  if (err instanceof require('multer').MulterError) {
    return res.status(400).json({ status: 'fail', message: `File upload error: ${err.message}` });
  }
  if (err.message.includes('File type not allowed')) {
    return res.status(400).json({ status: 'fail', message: err.message });
  }
  res.status(err.statusCode || 500).json({
    status: 'error',
    message: err.message || 'An unexpected internal server error occurred in Node service.',
  });
});

module.exports = app;

--- END: node_service/src/app.js ---


--- START: docker-compose.yml (relevant service definitions) ---
    ports:
      - ./flask_service:/app 
    environment:
    ports:
      - ./node_service:/usr/src/app # Mount for live reload with nodemon
    environment:
    image: mongo:latest
    ports:

(Note: For docker-compose.yml, only lines matching certain keywords were included.)
--- END: docker-compose.yml ---


